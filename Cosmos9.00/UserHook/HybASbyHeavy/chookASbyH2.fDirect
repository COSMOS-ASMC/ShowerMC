c
c     chookASbyH2:  This is a special user hook to compute
c                  AS generated by heavy primaries with
c                  generate='qas'.  This is a slave of chookASbyH.
c
      subroutine chookBgRunAS
      implicit none
#include "Zmanagerp.h"
      include "ZASbyH.h"  ! this is in UserHook
      integer ios, i


c      open component disk file,
c      We assume that  overall information is in the first 
c      and 2nd record of the direct access file.
c      and record number =3 to NoOfCompS + 2  have component showers.
c
c   *************** record organization *****************
c
c    First rec:  NoOfCompS, NdpethComp, E0
c    Second rec: Depths
c    later rec:  first collision depth (vertical) and sizes (and ages)
c
c   **************************************************** 


c        *** open direct access file *** 

c            YOU SHOULD GIVE
c        file and
c        recl (in bytes) 
c            below 
c        
c        
      open(13, file='../Data/cs', iostat=ios, status='OLD',
     *   access='DIRECT', form='unformatted',
     *   recl= 88  ) 

c        read direct access file.
c        Number of  compoentent showers
c        Number of  depths
c        Depth list

      read(13, rec=1, iostat=ios) NoOfCompS, NdepthComp, E0Comp
c     *      , FirstColDep

      if(ios .ne. 0) call cerrorMsg('c.s file error 1', 0)

      read(13, rec=2, iostat=ios)
     *      (DepthComp(i), i = 1, NdepthComp)     

      if(ios .ne. 0) call cerrorMsg('c.s file error 2', 0)
      if(NdepthComp .gt. NdepthCompM) then
         call cerrorMsg('Too many component shower layers', 0)
      endif

      end

      subroutine chookNEPIntA
      implicit none
#include  "Zcode.h"
#include  "Ztrack.h"
#include  "Ztrackv.h"
#include  "Zobs.h"
#include  "Zobsv.h"
      include "ZASbyH.h"
c  #include  "Ztrackp.h"
      
      

c   MovedTrack is the particle that made interaction
c   Pwork contains produced particles.
c   Nproduced has the number of particles in Pwork
c   IntInfArray(ProcessNo) contains the type of interaction
c
c        IntInfArray(ProcessNo).process  will have
c             'col' or 'decay'

      integer i, recn, ios, j
      integer noOfIntN             ! no. of interacting nucleons
      record /ptcl/ ptclA(maxHeavyMassN)  ! to get nucleon inf.
      real*8 u     ! uniform random number
      real*8 eSizeTemp(NdepthCompM), depStep, depFirst, dep
      real*8 ans, zobs, t, cosz, length, clenbetween2h, eno
      real*8  clen2thick
    

c        inquire the interacting nucleons
      call cqIntePtcl(ptclA, noOfIntN)
c          for each nucleon
      do i = 1, noOfIntN
c           select a component shower
         call rnde(u, 1)   ! get one unif. random. n.
c            compute record number of direct access file using u
         recn = u* NoOfCompS + 3
c            and read a component shower...
         read(13, rec=recn, iostat=ios) FirstColDep,
     *     (ElecSizeComp(j), j = 1, NdepthComp)  
         if(ios .ne. 0) then
            call cerrorMsg('read error of comp. shower', 0)
         endif

c         you may need to verify that
c         the primary energy of the component shower and 
c          ptclA.fm.p(4) is almost the same for safety.

         depFirst = DepthComp(1)   !  first depth
         depStep = DepthComp(2) - DepthComp(1)  ! equi step depth
c          move to real*8  array for use of kintp3
         do j =1, NdepthComp
            eSizeTemp(j) = ElecSizeComp(j)    ! log10( size )
         enddo
c              cos of c.s
         cosz = MovedTrack.vec.coszenith
c          compute size at  
         do j = 1, NoOfASSites
            zobs = ASObsSites(j).pos.depth 
c             current nucleon depth to obseration depth
c             (vertical depth)
            dep = zobs - MovedTrack.pos.depth 
            if(dep .gt. 0.) then
                if(abs(cosz) .gt. 0.5) then
c                         amount of air
                   t= dep/abs(cosz)
                else
c                  slant lenngth between two depths
                   length = clenbetween2h(
     *                  MovedTrack.pos.radiallen,
     *                  ASObsSites(j).pos.radiallen,
     *                  cosz)
c                         amount of air
                   t = clen2thick(
     *                MovedTrack.pos.height,
     *                cosz,  length)
                endif
c                  current obs depth corresponds to dep in c.s
                dep = t + FirstColDep
c                 interpolate; use diff. one if DepthComp is not
c                  equisteped.
                call kintp3(eSizeTemp, 1, NdepthComp,  depFirst,
     *              depStep, dep, ans)

c             *********************************
c                   for age
c                call kintp3(eAgeTemp, 1, NdepthComp,  depFirst,
c     *             depStep, dep, age)
c             *********************************

c                   IMPORTANT:   assume that eSizeTemp is in log10
                eno =    10.**ans * MovedTrack.wgt
                ASObsSites(j).esize =  ASObsSites(j).esize + eno

c             *********************************************
c               ASObsSites(j).age = ASObsSites(j).age +
c     *             eno * age
c             *********************************************
            endif
         enddo
      enddo
      end
