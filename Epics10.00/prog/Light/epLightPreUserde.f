
!>>>>>>>>>>>>>>>>>>>>>>>>>light
!           this is to replace 'call userde' in versions bef 9.00
!       before userde is called, we have to do business for "light"
!       so  all userde call's were replace by call epLightPreUserde
!       which include call userde 
      subroutine epLightPreUserde(info, aTrack )
      use modepLightPty
      use modepLightCounter
      use modUI
      implicit none
#include  "ZepTrackp.h"
#include  "ZepTrackv.h"
#include  "Zcnfig.h"
!#include  "ZepManager.h"

      integer,intent(in)::info ! 1 ptcl is going to die
                               !  0 alive
       type(epTrack):: aTrack   ! input. current track
      integer::epLightGetd    ! function
      integer::epLightGetB    ! function

      integer::countde, d, mn, B

      if( Cn >= MinQComp .and. Cn <= MaxQComp ) then  ! for possilbe quenching comp.
         if( info == 1 ) then
            dED(Cn) = dED(Cn) + Move%dE
         endif
         if( aTrack%p%charge > 1 ) then
            RdEH(Cn) =  RdEH(Cn) + Move%dE
         else
            RdES(Cn) =  RdES(Cn) + Move%dE
         endif
         ElossE(Cn) = ElossE(cn) + Move%dEeff
      endif
      ElossT(Cn) = ElossT(cn) + Move%dE

      countde = epLightGetd( Det%cmp(Cn)%CountDE )  ! get d part
      if( countde > 0 ) then
!            user routine must be called 
         call userde(info, aTrack, Move, Media(MediaNo))
!         if( cLcompNo > 0 ) then
!            if( .not. allocated( lightcomp( cLcompNo)%dE )) then
!               allocate( lightcomp( cLcompNo)%dE )
!            endif
!            lightcomp( cLcompNo)%dE = lightcomp( cLcompNo)%dE +
!     *       Move.dEeff
!         endif
      endif
      if(Light > 0 ) then
!           Light 11:  dE-->scinti lights are generated and pushed into
!                           stack, then ray trace is done
!                   charged ptcl path-->Cerenkov lights are generated and 
!                    lights are  pushed into stack, then ray trace is done

!                 12:  dE-->accumlated in each small cell in each component
!                          until  ordinary ptcl tracking is finished, then
!                          dE in each cell is treated as a psudo ptcl and
!                          stored in stack.  From each psudo ptcl, sciti
!                          lights are generated and stacked for ray tracing
!                    charged ptcl path-->teated same as 11.

!                 21: No ray trace is done.  
!                      dE-->same as 12 but accumulated dE is written
!                          into a file as  +primary
!                    charged ptcl path-->path info is written as psudo ptcl
!                          in the same file for dE

!                 22: +primay containing psudo ptcles generated by 21 
!                     are read and lights are  generated for ray trace.  
!                     This case is not treated
!                     here since, this routine is called only when
!                     particle loses energy.  
    
         if( cLcompNo  >  0 ) then
            B = epLightGetB( Det%cmp(Cn)%CountDE )   ! get B part
            if( Light == 21 ) then
                       ! 21: only store Edepo and track for Cerenkov 
               if( btest(B, 0) ) then
                  call  epLightStoreEdepo(info, aTrack)
               endif
               if( btest(B, 1) .and. info == 0 ) then
                    ! if info=1, energy is low and track is too short
                    ! so only info=0 case is for Cerenkov
                  aTrack%wl = Move%dl
                  call epLightWriteCPath(aTrack)  ! write path for Cerenkov
               endif
            elseif( Light == 12 ) then
              ! Cerekov is on-fly but for scinti store Edepo
               if( btest(B,0) ) then
                  call  epLightStoreEdepo(info, aTrack)
               endif
               if( btest(B,1) .and. info == 0) then
                  aTrack%wl = Move%dl
                  call eplightCerenkov(aTrack)
               endif
            elseif( Light == 11 ) then
                ! on-fly
!////////////////
!               write(0,*) ' B=',B, ' info=',info, ' dl',Move.dl
!/////////////
               if ( btest(B,0) ) then
                  call epLightScintiOnFly(info, aTrack)
               endif
               if( btest(B, 1) .and. info == 0 ) then
                  aTrack%wl = Move%dl
                  call epLightCerenkov(aTrack)
               endif
            elseif( Light == 22 ) then
               write(0,*)
     &          'Light=22 should not come to epLightPreUserde'
               stop
            else
               write(0,*) ' Light=',Light, ' is invalid '
               write(0,*) ' in epLightPreUserde '
               stop
            endif
         endif
      endif
      end

      real(4) function lightcomp(lcmpno)
      use modUI
      implicit none
      integer,intent(in)::lcmpno !  light comp. #

      integer::cn

      call epLightLcompNo2Cn(lcmpno, cn)
      if(cn > 0) then
         lightcomp = ElossE(cn)
      else
         lightcomp = 0.
      endif
      end
